该包中主要介绍 <创建型> 设计模式.
    1.<factory>工厂模式：
        <simple_factory>简单工厂模式 ： 在同一个需求中,要根据不同的参数来不同分支的事情.
            eg：在商场完成购物之后,根据消费的金额来选择不同的折扣的类型.   满500 -> 300 并赠送1张消费券   满1000 -> 打8折 赠送2张消费券.
            需求： [购物->结账]
            根据参数选择不同分支：参数：[消费金额]  不同分支：[折扣类型]

        <factory> 工厂模式：在同一个需求中,要根据不同的参数来不同分支的事情. 同简单工厂区别在于 可能 不同的参数 有多个.
            eg：有一个会员等级 和 会员积分  商场有2种类型的优惠  满减和打折  根据会员等级来决定 优惠类型  然后再根据会员积分来决定 优惠力度
            会员等级 -> 使用哪一种优惠类.  会员积分 -> 优惠多少.

        <abstract_factory>抽象工厂模式： 当涉及到产品族概念的时候,就需要使用 [抽象工厂] 的概念
            eg：在游戏中不同厂商的登录模式中,他们有同样的 登录、退出、注册等接口. 可以实现同一个接口之后. 不同厂商在实现不同的 接口方法体.



    2.<singleton>单例模式：
        <hungry>：饿汉式单例模式：最简单的单例模式.
            1.优点：简单.
            2.缺点：没办法实现懒加载. static静态变量在类加载时就会执行, 会永久消耗一定内存.

        <lazy>：懒汉式单例模式
            <SingletonOne> 最简单的懒汉式单例模式 -> 在getInstance()方法中 会出来线程安全问题.
            <SingletonTwo> 双重检索懒汉式单例模式 -> 多线程环境中足够安全,但可以通过反射来破坏单例.
            <SingletonThree> 嵌入类懒汉式单例模式 -> 仍然会有反射不安全的问题.
            <EnumSingleton> 枚举懒汉式单例模式 -> 足够安全.




    3.<builder> 建造者模式：Account.builder().setXXX().setXXX()...build();
        1.创建一个公共静态内部类 -> 和外部类相同的属性. -> 内部类中所有的set方法都返回this. -> 内部类中创建build()方法,可以验证部分参数之后,创建外部类并填充属性返回.
        2.外部类私有化默认构造函数和全参构造函数.  -> 提供一个 [静态] builder()方法 返回一个内部类.




    4.<原型模式>. Java的Object类中提供了 clone() 方法,对象进行克隆的时候,需要实现 Cloneable接口.  Java中的是浅克隆. 克隆的对象和原对象的引用指向的是同一个堆对象.
        如果要实现对象的克隆,需要先进行对象的序列化,之后再进行反序列化.

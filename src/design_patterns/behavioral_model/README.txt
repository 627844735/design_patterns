该包中主要介绍 <创建型> 设计模式.
    <factory>工厂模式：
        <simple_factory>简单工厂模式 ： 在同一个需求中,要根据不同的参数来不同分支的事情.
            eg：在商场完成购物之后,根据消费的金额来选择不同的折扣的类型.   满500 -> 300 并赠送1张消费券   满1000 -> 打8折 赠送2张消费券.
            需求： [购物->结账]
            根据参数选择不同分支：参数：[消费金额]  不同分支：[折扣类型]

        <factory> 工厂模式：在同一个需求中,要根据不同的参数来不同分支的事情. 同简单工厂区别在于 可能 不同的参数 有多个.
            eg：有一个会员等级 和 会员积分  商场有2种类型的优惠  满减和打折  根据会员等级来决定 优惠类型  然后再根据会员积分来决定 优惠力度
            会员等级 -> 使用哪一种优惠类.  会员积分 -> 优惠多少.

        <abstract_factory>抽象工厂模式： 当涉及到产品族概念的时候,就需要使用 [抽象工厂] 的概念
            eg：在游戏中不同厂商的登录模式中,他们有同样的 登录、退出、注册等接口. 可以实现同一个接口之后. 不同厂商在实现不同的 接口方法体.



    <singleton>单例模式：
        <hungry>：饿汉式单例模式：最简单的单例模式.
            1.优点：简单.
            2.缺点：没办法实现懒加载. static静态变量在类加载时就会执行, 会永久消耗一定内存.

        <lazy>：懒汉式单例模式
            <SingletonOne> 最简单的懒汉式单例模式 -> 在getInstance()方法中 会出来线程安全问题.
            <SingletonTwo> 双重检索懒汉式单例模式 -> 多线程环境中足够安全,但可以通过反射来破坏单例.
            <SingletonThree> 嵌入类懒汉式单例模式 -> 仍然会有反射不安全的问题.
            <EnumSingleton> 枚举懒汉式单例模式 -> 足够安全.